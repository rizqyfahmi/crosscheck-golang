package hash_test

import (
	"errors"

	"github.com/golang/mock/gomock"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"golang.org/x/crypto/bcrypt"

	"crosscheck-golang/app/exception"
	"crosscheck-golang/app/utils/hash"
	mock "crosscheck-golang/test/mocks"
)

var _ = Describe("Hash", func() {
	var mockPassword string
	var mockHashedPassword string
	var mockBcrypt *mock.MockBcrypt
	var testHash hash.Hash

	BeforeEach(func() {
		ctrl := gomock.NewController(GinkgoT())
		defer ctrl.Finish()

		mockPassword = "HelloPassword"
		mockHashedPassword = "$2a$12$kQGn.8oQAlQV8yXyIWNjKuIiv4.eB6P3IoF8qAmg0lGePiKDDV8Gq"
		mockBcrypt = mock.NewMockBcrypt(ctrl)
		testHash = hash.New(mockBcrypt)
	})

	Describe("Hash Password", func() {
		Context("When password fails to hash", func() {
			It("returns the same error as the error returned by GenerateFromPassword from Bcrypt", func() {

				mockBcrypt.EXPECT().GenerateFromPassword([]byte(mockPassword), bcrypt.DefaultCost).Return(nil, errors.New(exception.ErrorEncryption))

				result, err := testHash.HashPassword(mockPassword)

				Expect(err).Should(HaveOccurred())
				Expect(err).Should(MatchError(exception.ErrorEncryption))
				Expect(result).Should(BeNil())
			})
		})

		Context("When the password is hashed successfully", func() {
			It("returns the same hashed password as generated by GenerateFromPassword from Bcrypt", func() {
				mockBcrypt.EXPECT().GenerateFromPassword([]byte(mockPassword), bcrypt.DefaultCost).Return([]byte(mockHashedPassword), nil)

				result, err := testHash.HashPassword(mockPassword)

				Expect(err).Should(Succeed())
				Expect(result).ShouldNot(BeNil())
				Expect(*result).Should(Equal(mockHashedPassword))

			})
		})
	})

	Describe("Compare Password", func() {
		Context("When password fails to be compare", func() {
			It("returns the same error as the error returned by CompareHashAndPassword from Bcrypt", func() {
				mockDifferentPassword := "OlaPassword"
				mockBcrypt.EXPECT().CompareHashAndPassword([]byte(mockHashedPassword), []byte(mockDifferentPassword)).Return(errors.New(exception.ErrorEncryption))

				err := testHash.ComparePassword(mockHashedPassword, mockDifferentPassword)

				Expect(err).Should(HaveOccurred())
				Expect(err).Should(MatchError(exception.ErrorEncryption))
			})
		})

		Context("When hashed password is successfully compared", func() {
			It("returns nothing (nil)", func() {
				mockBcrypt.EXPECT().CompareHashAndPassword([]byte(mockHashedPassword), []byte(mockPassword)).Return(nil)

				err := testHash.ComparePassword(mockHashedPassword, mockPassword)

				Expect(err).Should(Succeed())
			})
		})
	})
})
